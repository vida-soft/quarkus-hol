== Dependency injection with Quarkus and Jakarta EE

One of the most relevant and long-lasting concepts in object-oriented programming, embedded into the foundation of all web server frameworks is the Dependency injection.
These techniques also allow to achieve the so called "inversion of control" (IoC for short), where the chain of classes, depending on one another is reversed and decoupled.
This allows the developer to change the implementation of one module with another, without having to retouch the whole chain of dependencies, but it also helps instantiating dependencies, without concerning about the initialization, such as constructors, variables and other related dependencies.
A way to achieve the inversion of control is having an IoC container.
The IoC container represents an API that stores, manages and controls instantiations of dependencies.
One such container is the Jakarta EE CDI.

TIP: There is a very good example on what dependency injection is, much easier to understand.
Imagine your class is a small child, who wants to take something out from the upper shelf of a fridge.
They can either do it themselves and risk making a mess, like dropping and breaking stuff, or they can ask its parent (IoC container), to give it to them.
The parent has the knowledge, height and strength to be capable to know what is good for the child, whether they should have that item, or a substitute and pass the item to the child safely.

=== What is CDI

As mentioned above CDI (Context and Dependency Injection) is one of the specifications of Jakarta EE, that is capable of managing dependencies within your application using scopes (we'll talk about them in a bit).
Instead of using constructors to create instances and connections between the modules of your application, you can rely on the CDI, to provide your classes with the instance they need.

During any application development one huge role, that plays into good practices is the separation of concerns.
This means that a class or a method should do exactly the thing they are supposed to do, without any additional jobs, which we call side effects.
So for example a Resource class is supposed to accept requests, validate queries and return responses, but not look into connecting with the database, building a query or executing complex operations directly on the database, such as performing multiple queries at once.
This is business logic, that is suitable to live on a separate layer in our server.
This layer is usually called a service.
The service class will do all the hard job regarding all additional operations out request has to perform, keeping our resource method clean from any additional distractions.

[TIP]
====
Layering within your application is subjective.
You are able to do whatever you like with your code, with one rule on the thumb - keep it clear and consistent.
So depending on the framework you are using, you have to figure out how to better structure your project to make it easy to understand and maintain. 

If your business logic is doing more than just getting some data as is, than maybe this is suitable for a service.
Depending on the framework you are using, you might need to also have a Data Access Object layer (DAO) or Repository layer where you keep all your queries to the database.
With Quarkus and Panache those types of layers are not needed, as the Panache Active Record pattern already serves as such a layer.
====

In Quarkus, the CDI implementation is provided by https://quarkus.io/blog/quarkus-dependency-injection/[Quarkus ArC].
Let's see how we can apply CDI in action for our project and explain how everything works.

=== The Application and Request scopes

To begin, we are going to create the `UserResource` class, which is going to contain two methods:

- `registerUser`
- `loginUser`

[source,java]
----
@Path("user")
public class UserResource {

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public Response registerUser(NewUserDTO newUserDTO) {

    }

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response loginUser(LoginDTO login) {

    }

}

public class NewUserDTO extends UserDTO {

    private String password;
    private UserType userType;

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public UserType getUserType() {
        return userType;
    }

    public void setUserType(UserType userType) {
        this.userType = userType;
    }
}

public class LoginDTO {

    private String userName;
    private String password;

    public String getUserName() {
        return userName;
    }

    public void setUserName(String username) {
        this.userName = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

public enum UserType {

    AUTHOR, SUBSCRIBER, MANAGER;

}

----

As you may notice `NewUserDTO` extends `UserDTO`, which used to contain the password property.
This property was previously being used by the `AuthorDTO`, which also extends the `UserDTO`, in order to create the author.
But now as we have the `NewUserDTO`, we need to move that field there.
 +
We also don't need the `AuthorResource.createAuthor` method, as all user creations will be managed from `UserResource` from now on.

With the current knowledge we have, our implementation would look something like this:

[source,java]
----
@Path("user")
public class UserResource {

    @POST
    @Transactional
    @Consumes(MediaType.APPLICATION_JSON)
    public Response registerUser(NewUserDTO newUserDTO) {
        if (checkIfNull(newUserDTO.getUserName(), newUserDTO.getPassword(),
                newUserDTO.getFirstName(), newUserDTO.getLastName(), newUserDTO.getUserType(), newUserDTO.getEmail())) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Optional<User> existingUser = User.find("userName = ?1 or email = ?2", newUserDTO.getUserName(),
                newUserDTO.getEmail()).firstResultOptional();
        if (existingUser.isPresent()) {
            return Response.status(Response.Status.CONFLICT).build();
        }

        User createdUser = null;
        switch (newUserDTO.getUserType()) {
            case AUTHOR:
                createdUser = new Author(newUserDTO.getUserName(), newUserDTO.getPassword(), newUserDTO.getFirstName(),
                        newUserDTO.getLastName(), newUserDTO.getEmail(), true, 0);
                break;
            case MANAGER:
                createdUser = new Manager(newUserDTO.getUserName(), newUserDTO.getPassword(), newUserDTO.getFirstName(),
                        newUserDTO.getLastName(), newUserDTO.getEmail());
                break;
            case SUBSCRIBER:
                createdUser = new Subscriber(newUserDTO.getUserName(), newUserDTO.getPassword(), newUserDTO.getFirstName(),
                        newUserDTO.getLastName(), newUserDTO.getEmail(), null, LocalDate.now().plusYears(1),
                        null);
                break;
        }

        createdUser.persist();
        return Response.status(Response.Status.CREATED).build();
    }

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response loginUser(LoginDTO login) {
        if (checkIfNull(login.getUsername(), login.getPassword())) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            User loggedUser = User.find("userName = ?1 and password = ?2", login.getUsername(), login.getPassword())
                    .firstResult();
            if (loggedUser == null) {
                return Response.status(Response.Status.UNAUTHORIZED).build();
            } else {
                return Response.ok(new UserDTO(loggedUser)).build();
            }
        }
    }

    private boolean checkIfNull(Object... fields) {
        for (var field : fields) {
            if (field == null) {
                return true;
            }
        }

        return false;
    }

}
----

But from what you can see here, there is too much stuff in one place.
We're doing data validations, database lookups, conditional user creations... 
Oh! And did you notice?
We're storing the user's password IN PLAIN TEXT!

As mentioned earlier a resource class should do simple things.
It should take data and return data.
Any additional operations, are better to happen upon a separate layer.
So let's create that layer, shall we?

Create a class in `user` package, called `UserService`.
This class will contain all of our additional operations, regarding user registration and login.
 +
Then move some of the code of `UserResource` to the user service.

[source,java]
----
public class UserService {

    public User registerUser(String firstName, String lastName, String email, String username, String password, UserType userType) {
        User createdUser = null;
        switch (userType) {
            case AUTHOR:
                createdUser = new Author(username, password, firstName, lastName, email, true, 0);
                break;
            case MANAGER:
                createdUser = new Manager(username, password, firstName, lastName, email);
                break;
            case SUBSCRIBER:
                createdUser = new Subscriber(username, password, firstName, lastName, email, null, LocalDate.now().plusYears(1), null);
                break;
        }

        createdUser.persist();
        return createdUser;
    }

    public Optional<User> loginUser(String username, String password) {
        return User.find("userName = ?1 and password = ?2", username, password).firstResultOptional();
    }

}
----

And now let's see how we can call this class from `UserResource`.
Truth is, it's fairly simple.

. Add `@ApplicationScoped` annotation on `UserService` class
+
[source,java]
----
@ApplicationScoped
public class UserService {...}
----

. In `UserResource`, define `UserService` as a global property and add `@Inject` on that property.
+
[source,java]
----
@Path("user")
public class UserResource {

    @Inject
    UserService userService;

    @POST
    @Transactional
    @Consumes(MediaType.APPLICATION_JSON)
    public Response registerUser(NewUserDTO newUserDTO) { ... }

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response loginUser(LoginDTO login) { ... }
}
----

. Now let's start using `userService` inside our code.
+
[source,java]
----
    @POST
    @Transactional
    @Consumes(MediaType.APPLICATION_JSON)
    public Response registerUser(NewUserDTO newUserDTO) {
        if (checkIfNull(newUserDTO.getUserName(), newUserDTO.getPassword(),
                newUserDTO.getFirstName(), newUserDTO.getLastName(), newUserDTO.getUserType(), newUserDTO.getEmail())) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Optional<User> existingUser = User.find("userName = ?1 or email = ?2", newUserDTO.getUserName(),
                newUserDTO.getEmail()).firstResultOptional(); <1>
        if (existingUser.isPresent()) {
            return Response.status(Response.Status.CONFLICT).build();
        }

        userService.registerUser(newUserDTO.getFirstName(), newUserDTO.getLastName(), newUserDTO.getEmail(),
                newUserDTO.getUserName(), newUserDTO.getPassword(), newUserDTO.getUserType()); <.>
        return Response.status(Response.Status.CREATED).build();
    }

    @POST
    @Path("login")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response loginUser(LoginDTO login) {
        if (checkIfNull(login.getUsername(), login.getPassword())) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            Optional<User> loggedUser = userService.loginUser(login.getUsername(), login.getPassword()); <1>
            return loggedUser
                    .map(u -> Response.ok(new UserDTO(u)).build())
                    .orElseGet(() -> Response.status(Response.Status.UNAUTHORIZED).build());
        }
    }
----
<1> As you can see, we can refer to `UserService` like we would with any other instance of a class.

.Scopes in CDI
*****************************************
In CDI every dependency, also called bean, has its own rate of instantiation and lifespan.
This is called "scope".
In vanilla CDI, the CDI, defined by Jakarta/Java EE, there are five scopes:

- `@RequestScoped` - upon every new request to the server a new instance of that class is created.
When the response has been returned, the instance is destroyed.
This allows multiple clients to request the same endpoint, with their own data and parameters, without interfering with each-other.
Upon creations of these requests, the CDI implementation will decide how to manage the load and might create separate threads to run multiple requests simultaneously.

- `@ApplicationScoped` - one instance of the class is created for the whole lifespan of the server's runtime.
Once an ApplicationScoped dependency has been injected into a class, it will create a single instance (singleton), which will be passed serverwide every time it's been injected, regardless of the scope of the depending class.
 +
For example, if the class is RequestScoped, each instance of that class will get the same instance of ApplicationScoped class.
This means that the ApplicationScoped annotation is suitable for stateless classes, which are not subject to changes.
It is not recommended to define stateful properties into an ApplicationScoped class, such as user data.
 +
Service classes are good example suitable for the `@ApplicationScoped` annotation.
They mostly contain methods, which do the same job every time and we do not need more than one instance of such a class.

- `@SessionScoped` - those type of dependencies have active instance during the lifetime of a user session.
When an user opens the page of a website for the first time, they will get a session cookie with item, called `JSESSIONID`.
The `JSESSIONID` is an identifier which the client then passes to the server upon each request.
With it CDI is capable of recognizing the user and binding their data with the `@SessionScoped` class instance.
`@SessionScoped` will create as many instances, as active clients are on the server.
It is suitable for storing user data, such as their email, permissions, preferences and so on.

- `@ConversationScoped` - this scope allows for the developer do control the creation and destruction of the instance.
Followed with injection of `jakarta.enterprise.context.Conversation` and methods `conversation.begin()` and `conversation.end()`, the developer is able to decide when the instantiation should start and where it should end.
+
NOTE: Both `@SessionScoped` and `@ConversationScoped` classes need to implement the `Serializable` interface, due to their long-lasting as those instances are stored int the user's HTTP session, which is sometimes saved as a file on the disk.

- `@Dependant` - this scope inherits the scope of the depending class.
If you inject a Dependant class into `@RequestScoped` bean, CDI will create a new instance with Request scope, if you do it in `@ApplicationScoped` bean, it will do it with a single instance, same as the depending class.

The instances passed to each class, injecting those dependencies are proxies.
In order to guarantee safety, you can never access and modify the real instance through reflection.
This is important for a service that is meant to be active 24/7 and be robust.

CAUTION: Due to the way proxies are implemented, mixing scopes in some CDI implementations may, or may not work.
For example injecting a `@RequestScoped` dependency into `@ApplicationScoped` bean on some servers may result in that instance being injected once for the whole lifespan of the `@ApplicationScoped` bean.
This may cause issues, such as getting the same data on each new request, instead of getting newer data for that request.

In Quarkus ArC there are 3 scopes implemented and one non-proxied scope, respectively - `Request`, `Application`, `Dependant` and Singleton scopes.
Dependencies, annotated with `@Singleton` act simmliarly to the `@ApplicationScoped`, with the difference that they are not proxied, meaning that the real instance of the entity is injected.
This allows better performance in some occasions.
Read more about `@Singleton` beans https://quarkus.io/guides/cdi#what-scopes-can-i-actually-use-in-my-quarkus-application[here].


Due to the fact, that Quarkus servers are meant to be stateless.
There's no out-of-the-box support for `SessionScoped` and `ConversationScoped` annotations,
meaning all the user data and configurations should come from outside in the form of a token (JWT for example).

NOTE: Usually Resource endpoints should be annotated with some kind of scope in order for CDI to establish access to them.
The most commonly used scope is `@RequestScoped`.
With Quarkus ArC, though, resources are reconized and by default the `@Singleton` scope is given to them, unless you overide it explicitly, by adding your scope.
This works only for endpoints, so if you want to inject any other dependency it must have at least `@Dependant` scope.

*****************************************

Going back to our project, we mentioned that we are saving the user with plain text password.
As you may suggest this is very bad idea, so let's do something about it.

First add a new field to the user entity, called `salt`.
Now let's create a new class and package `security.PasswordService`.
You should be guessing what comes next...

[source,java]
----
@ApplicationScoped
public class PasswordService {

    public String encryptPassword(String password, String salt) {

    }
    
    public String generateSalt() {
        
    }

}
----

Just encrypting the password will not be enough to have a fully protected password.
It will still be susceptible to https://www.beyondidentity.com/glossary/rainbow-table-attack["Rainbow attacks"], which are a way to reverse engineer the password.
Adding salt to the password, which is a random string of characters, then using encryption algorithm before saving the password to the database will make the password unbreakable.
Even if somebody got the user's hashed password and the salt, they will have a hard time to figure out the password, as due to encryption, which produces a way different hash, than what encrypting a single password would do.

Having said that, the implementation of our password service, would look like this:

[source,java]
----
@ApplicationScoped
public class PasswordService {

    private static final String ENCRYPTION_KEY = "$oME$anD0mKey!@#";
    private static final int SALT_LENGTH = 8;

    public String encryptPassword(String password, String salt) {
        var saltedPassword = password + salt;

        Key aesKey = new SecretKeySpec(ENCRYPTION_KEY.getBytes(), "AES");
        try {
            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(saltedPassword.getBytes());
            return new String(encrypted);
        } catch (Exception e) {
            return password;
        }
    }

    public String generateSalt() {
        StringBuilder sb = new StringBuilder();
        Random random = new Random();
        for (int i = 0; i < SALT_LENGTH; i++) {
            sb.append((char) random.nextInt());
        }

        return sb.toString();
    }

}
----

Now it's time to add that to our `UserService`.

[source,java]
----
@ApplicationScoped
public class UserService {

    @Inject
    PasswordService passwordService; <.>

    public User registerUser(String firstName, String lastName, String email, String username, String password, UserType userType) {
        User createdUser = null;
        switch (userType) {
            case AUTHOR:
                createdUser = new Author(username, password, firstName, lastName, email, true, 0);
                break;
            case MANAGER:
                createdUser = new Manager(username, password, firstName, lastName, email);
                break;
            case SUBSCRIBER:
                createdUser = new Subscriber(username, password, firstName, lastName, email,
                        null, LocalDate.now().plusYears(1), null);
                break;
        }

        var salt = passwordService.generateSalt(); <.>
        createdUser.salt = salt;
        createdUser.password = passwordService.encryptPassword(password, salt);

        createdUser.persist();
        return createdUser;
    }

    public Optional<User> loginUser(String username, String password) {
        User user = User.find("userName", username).firstResult(); <.>
        if (user != null) {
            var hashedPassword = passwordService.encryptPassword(password, user.salt);
            if (hashedPassword.equals(user.password)) {
                return Optional.of(user);
            }
        }

        return Optional.empty();
    }

}
----
<.> Just like injecting `UserService` into `UserResource`, here we are injecting the `PasswordService`.
When the `PasswordService` proxy is called for the first time, CDI will instantly create a singleton instance, which will remain active through the whole runtime of the server.

<.> Here, before we persist the newly created user, we first need to encrypt their password.
First we need to generate the salt and set it to the user, then we need to call the `encryptPassword()` method and set the password to the new user.
Finally we are able to persist, the user.

<.> Now that we store the encrypted password, we cannot directly compare the plain text password with the one stored into the database.
To be able to validate the user's password, we first need to encrypt it, and to do so, we need the same salt we used during the encryption in the first place, so this requires to pull out the user from the database to get their salt.
If both the encrypted passwords match, then we can return that user to the resource.

Now if we try to create a new user and try to query the database, to see how they were created, we'll stumble upon the following result:

image::img/salty-password.jpg[align=center]


=== Injecting `EntityManager` with CDI

Remember when we instantiated the `EntityManager` from the constructor of a resource?
The reason why this worked, is because in Quarkus, CDI works even on constructor level.
And having said that JTA-managed `EntityManager` is controlled by the CDI container as well.

Let's go back to our `CommentResource` and see how we can optimize our class.
Knowing that we can separate more complex operations into a different layer of our package (called service ðŸ˜‰), let's move some stuff to the `CommentService`...

[source,java]
----
@ApplicationScoped
public class CommentService {

    @Inject
    EntityManager entityManager; <.>

    public Comment createComment(String content, User author, Article article) {
        Comment comment = new Comment(content, author, LocalDateTime.now());
        comment.article = article;
        comment.persist();
        return comment;
    }

    public Optional<CommentDTO> getCommentById(long commentId) {
        return entityManager.createNamedQuery(Comment.GET_COMMENT_BY_ID, CommentDTO.class)
                .setParameter("commentId", commentId)
                .getResultStream()
                .findFirst();
    }

}
----
<.> As you can see `EntityManager` could be injected using the same techniques as the one used for other dependencies.
It's worth mentioning that the instance of JTA managed `EntityManager` is RequestScoped.

As for the `CommentResource` class, it will end up looking like this:

[source,java]
----
@Path("/article/{id}/comment")
public class CommentResource {

    @Inject
    CommentService commentService;

    @POST
    @Transactional
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createComment(@PathParam("id") Long articleId, CommentDTO commentDTO) {
        if (articleId == null || articleId < 1 || commentDTO.getAuthorId() == null || commentDTO.getAuthorId() < 1) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        User author = User.findById(commentDTO.getAuthorId());
        if (author == null) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Article article = Article.findById(articleId);
        if (article == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }

        Comment comment = commentService.createComment(commentDTO.getContent(), author, article);

        return Response.created(URI.create(String.format("/article/%d/comment/%d", articleId, comment.id))).build();
    }

    @GET
    @Path("/{commentId}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getCommentById(@PathParam("commentId") Long commentId) {
        if (commentId == null || commentId < 1) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            return commentService.getCommentById(commentId)
                    .map(c -> Response.ok(c).build())
                    .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build());
        }
    }
}
----

=== `@PostConstruct` and `@PreDestroy`

In a typical class, the way you initialize an instance and its properties is by using the constructor.
But in CDI managed class there is more safe and convenient way to do so.
By creating a method and annotating it with `@PostConstruct`, CDI will invoke that method, the moment, the class is ready to use all of it's dependencies.

For example, let's say we want to log every attempt to access the `UserResource` endpoints.

[source,java]
----
@Path("user")
public class UserResource {

    Logger logger = Logger.getLogger(this.getClass().getName());

    @Inject
    UserService userService;

    @Inject
    HttpServerRequest request;

    @PostConstruct
    void init() {
        String requestPath = request.uri();
        var originIp = request.remoteAddress().toString();
        logger.log(Level.INFO, "URL call attempt {0} from {1}", new String[] {requestPath, originIp});
    }

    //Endpoints
}
----

As you can see, we're taking the request data from the class `io.vertx.core.http.HttpServerRequest`, which is injected by CDI.
If we did that in the constructor of the class, we wouldn't have been able to use that class.
This comes to our conclusion, that the execution of `@PostConstruct` happens after all of our dependencies are injected.

`@PreDestroy` works in the same manner, but to see it in work, you'll need to annotate your resource with `@RequestScoped`, as the scope of resource by default is `@Singleton` and `@PreDestroy` never gets called.
Then we can create a method like this:

[source,java]
----
@RequestScoped
@Path("user")
public class UserResource {

    Logger logger = Logger.getLogger(this.getClass().getName());

    @Inject
    UserService userService;

    @Inject
    HttpServerRequest request;

    @PostConstruct
    void init() {...}

    @PreDestroy
    void destroy() {
        String requestPath = request.uri();
        var originIp = request.remoteAddress().toString();
        logger.log(Level.INFO, "Scope completed for {0} from {1}", new String[] {requestPath, originIp});
    }

    //Endpoints
}
----

Once the response of the endpoint has been returned, the `destroy()` method will be called, and execute all the code inside.
You can use this to close certain kind of connections or execute some kind of a task.
Or like in our case, just log something.

=== Interceptors and decorators

One other useful tool CDI provides is the ability to intercept or decorate the executions of a CDI-managed method.
Basically both do the same thing, but serve a different purpose.

An example of where an interceptor or decorator could be used, would be in the cases where something's meant to happen, but it is neither a concern for the resource, nor for the service class.
In our project when we create an article or a comment, we use to set the publish date inside the constructor of the Article/Comment.
There's nothing wrong with that, but in theory it's an action that is not a concern for either of the service classes, making the article.
It is also repetitive.
Actions or operations which do not belong to the purpose of the single responsibility of a method are called *cross-cutting concerns*.
So what can we do about it?

==== Interceptors

First, since both articles and comments have the same property called `publishDate` (or `created`), we can unify those in an abstract class, to inherit them on both classes.

[source,java]
----
@MappedSuperclass
public class PublishedContent extends AbstractEntity {

    public LocalDateTime publishDate;
    public LocalDateTime lastModified;

}

//And then extend our entities, and remove their date property

public class Article extends PublishedContent {...}

public class Comment extends PublishedContent {...}

----

Now in order to attach the appropriate dates to our content, we need to create some annotations.
To make things cleaner, let's add a new package, called `interceptors`, and add two new annotations:

- `@CreatesContent`
- `@ModifiesContent`

[source,java]
----
import javax.interceptor.InterceptorBinding;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@Inherited
@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface CreatesContent {
}

@Inherited
@InterceptorBinding
@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface ModifiesContent {
}
----

Then we need to place these annotations on the service methods we are going to intercept.

[source,java]
----
@ApplicationScoped
public class ArticleService {

    @CreatesContent
    public Article createArticle(String title, String content, Author author) {
        Article article = new Article(title, content, author);
        article.persist();
        return article;
    }

    @ModifiesContent
    public void editArticle(Article article, String title, String content) {
        article.title = title;
        article.content = content;
    }

}
----

You can do the same with the comment.

But we're not finished.
Although we have the annotations we are still not intercepting anything, as we have not implemented any logic for that. Let's do it.

Inside the `interceptors` package, let's create two new classes - `CreatesContentInterceptor` and `ModifiesContentInterceptor`.

[source,java]
----

@Interceptor <1>
@CreatesContent <2>
@Priority(Interceptor.Priority.APPLICATION) <3>
public class CreatesContentInterceptor {

    @AroundInvoke
    public Object contentCreated(InvocationContext invocationContext) throws Exception {
        Object returnedObject = invocationContext.proceed(); <4>
        if (returnedObject instanceof PublishedContent) {
            var content = (PublishedContent) returnedObject;
            content.publishDate = LocalDateTime.now();
            content.lastModified = LocalDateTime.now();
        }

        return returnedObject;
    }

}

@Interceptor <1>
@ModifiesContent <2>
@Priority(Interceptor.Priority.APPLICATION) <3>
public class ModifiesContentInterceptor {

    @AroundInvoke
    public Object contentModified(InvocationContext invocationContext) throws Exception {
        Object[] arguments = invocationContext.getParameters(); <5>
        for (var argument : arguments) {
            if (argument instanceof PublishedContent) {
                var content = (PublishedContent) argument;
                content.lastModified = LocalDateTime.now();
            }
        }

        return invocationContext.proceed(); <6>
    }
}

----
<1>  With the `@Interceptor` annotation, we tell our application server that this class serves as an interceptor.

<2> The annotation we created will tell CDI to which classes it should listen to invoke them.

<3> The `@Priority` annotation defines the order of invocation of annotations.
Its value is of type integer.
The higher the priority the least the chance of this annotation being called first.
This is helpful for example when one method has two interceptors.
With the `@Priority` annotation you can define which interceptor gets called first.
`Interceptor.Priority.APPLICATION` equals 0, meaning that this interceptor it will be called with highest priority.

<4> `invocationContext.proceed()` means to execute the intercepted method.
You can run your method during interception.
Here this is done, so we can get the return value of that method, which we are interested in.
Then we are checking if the returned type is the type we need and set the date of the content.

<5> In this case we are interested of the passed entity, which is going to be updated.
We are considering that all of our update methods will contain the entity which is going to be updated.
If that's not the case, this interceptor won't do anything.

<6> Here we are not interested of the interceptor's result, so we are directly returning whatever needs to be returned. (In object oriented programming `void` is also a return type)

NOTE: Keep in mind that in our examples the `@Transactional` scope is running during this operations, as it is annotated on the resource level.
So any changes created to the entities in the scope of the interceptor are going to reflect on the entity.
If your implementation is different, you'll need to adjust it to ensure transactions are occurring and entities are attached.

Knowing all that, we can understand how the `@Transactional` annotation is working.
It is an interceptor responsible for managing the transactions during the execution of a method.

==== Decorators

Unlike interceptors, which are meant to be used mostly to modify unrelated to the resource or service data, decorators have a bit more different purpose.
The use of decorators, as the name suggests, is meant do _decorate_ the data.
A scenario where a decorator would be useful is if you make some kind of request, but the response contains stuff that no service or resource is responsible to provide.

Let's develop our `Advertiser` entity to see how it can come in handy, when using decorators.

- Create `AdvertiserResource` that supports some type of CRUD operations
- Create `AdvertiserService` if needed
- Create some `Advertiser` entities

In most blogs or magazines you'll see sponsored messages or a list of sponsors.
In our Magazine Manager, the advertiser is a sponsor who has donated to support an article.
We want to list those advertiser names into the content of an article.
This creates a challenge as we neither want to edit the content of the article, nor do we want to introduce a logic to the `ArticleService` that is not a concern for it.
So what do we do?
We create a decorator.

First, let's move the `getArticle()` method into `ArticleService`.
To simplify stuff, we're going to ditch the `withComments` part.
It was used only to demonstrate how `NamedQueries` work, but in real practice you wouldn't do it like that for something as simple.

This would make our `ArticleResource` and `ArticleService` look like this:

[source,java]
----
@RequestScoped
@Path("/article")
public class ArticleResource {

    @Inject
    ArticleService articleService;

    //endpoints
    
    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getArticle(@PathParam("id") Long articleId) {
        if (articleId == null) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        return articleService.getArticle(articleId)
                .map(article -> Response.ok(new ArticleDTO(article)).build())
                .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build());
    }


    //endpoints
}

@ApplicationScoped
public class ArticleService {

    public Optional<Article> getArticle(long articleId) {
        return Article.findByIdOptional(articleId);
    }

    @CreatesContent
    public Article createArticle(String title, String content, Author author) {
        Article article = new Article(title, content, author);
        article.persist();
        return article;
    }

    @ModifiesContent
    public void editArticle(Article article, String title, String content) {
        article.title = title;
        article.content = content;
    }
}
----

Then we recommend to rename the `ArticleService` into `ArticleServiceImpl`, so you can turn the `ArticleService` class into interface.
Add all the methods of `ArticleServiceImpl` into that interface.

[source,java]
----    
public interface ArticleService {

    Optional<Article> getArticle(long articleId);

    Article createArticle(String title, String content, Author author);

    void editArticle(Article article, String title, String content);

}

@ApplicationScoped
public class ArticleServiceImpl implements ArticleService {

    public Optional<Article> getArticle(long articleId) {...}

    @CreatesContent
    public Article createArticle(String title, String content, Author author) {...}

    @ModifiesContent
    public void editArticle(Article article, String title, String content) {...}

}
----

Then it's time to build our decorator class.

[source,java]
----
@Decorator <.>
public abstract class ArticleDecorator implements ArticleService { <.>

    @Inject
    @Delegate <.>
    ArticleService articleService;

    @Override
    public Optional<Article> getArticle(long articleId) {
        return articleService.getArticle(articleId)
                .map(this::decorateArticle);
    }

    private Article decorateArticle(Article article) {
        var advertisers = article.advertisers;
        var message = String.format("\nThis article has been sponsored by: %s",
                advertisers.stream().map(a -> a.name).collect(Collectors.joining(", ")));
        var decoratedArticle = new Article(article.title, article.content + message, article.author); <.>
        decoratedArticle.id = article.id;
        return decoratedArticle;
    }
}
----
<.> We use the `@Decorator` annotation to notify CDI that this class will be called to wrap the real instance of `ArticleServiceImpl`.

<.> The decorator should be abstract and implement `ArticleService` as well.
Making it abstract let us control on which methods should we implement decorators.

<.> The `@Delegate` annotation is mandatory for CDI to inject the appropriate implementation for `ArticleService`.
+
NOTE: Usually when you pass Inject on an interface, CDI will try and look for implementations with CDI context.
We'll talk more about that in our "_Producers and Alternatives_" section.

<.> At the ned we create a new instance of `Article` in order to detach it from the database, so we don't cause any changes on the attached entity we might be working with.
As you can see by the parameters, we can't be sure when is this method called.
It might be called in `@Transactional` scope, so we have to make sure that we are not working directly with the entity.

Now add some advertisers to some articles, so you can experience the decoration magic.

[source,java]
----
@RequestScoped
@Path("/article")
public class ArticleResource {

    //Other endpoints

    @PATCH
    @Transactional
    @Path("{id}/advertiser/{advertiserId}")
    public Response addAdvertiserToArticle(@PathParam("id") Long id, @PathParam("advertiserId") Long advertiserId) {
        if (id == null || advertiserId == null) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Article article = Article.findById(id);
        Advertiser advertiser = Advertiser.findById(advertiserId);

        if (article == null || advertiser == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }

        article.advertisers.add(advertiser);
        return Response.status(Response.Status.NO_CONTENT).build();
    }
}
----

Now when you make a call for getting an article by id, you should get a response similar to this:

[source,json]
----
{
    "authorId": 1,
    "content": "The quick brown fox runs over the lazy dog.\nThis article has been sponsored by: Google",
    "id": 3,
    "title": "Article for the soul."
}
----

[TIP]
====
Want to do some more decorators?

Why don't you try and make a decorator which is going to extract the image of the sponsor upon getting it and convert that image to Base64 string?

Here are some tips.

- Create an interface `AdvertiserMapper` which is going to convert `Advertiser` to `AdvertiserDTO`
- Create an implementation for that mapper
- Create a decorator which is going to take the blob byte content of the advertiser's logo and convert it to base64 string.
- Attach that string logo to the DTO of the advertiser.
====

=== Producers and alternatives

So far we have injected an instance of a single class.
But what happens when you have multiple implementations of a dependency or you want to use CDI to provide e certain type of information?
In a typical program, when facing such a scenario, you would likely use the factory pattern and let the factory class decide which instance to return.
In CDI on the other hand you can use the power of annotations to control what and when to be injected into the annotated class.

==== Producers

When you have two or more implementations of a dependency, or you want to inject something that by default is not a CDI bean, you can use CDI producers, which will generate the value you need and inject it.
For example let's have a look at our `ArticleDecorator` class.
We are getting all the advertisers and decorate an article with them.
But let's say that we want to decorate the article only with `GOLD` advertisers.
One way to do it, would be to pull out the advertisers with a query, filtering them by their type.
Other way to do it, would be by creating a producer.

For a start, create a package, called `producers` inside the `advertiser` package.
Inside, create the class `AdvertiserProducer`.
Next, create three new annotations - `@Gold`, `@Silver`, `@Bronze`.

[source,java]
----
@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Gold {

    SponsorPackage SPONSOR_PACKAGE = SponsorPackage.GOLD; <1>

    @Nonbinding <2>
    int limit() default 0;

}

@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Silver {
    SponsorPackage SPONSOR_PACKAGE = SponsorPackage.SILVER; <1>

    @Nonbinding <2>
    int limit() default 0;
}

@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Bronze {

    SponsorPackage SPONSOR_PACKAGE = SponsorPackage.BRONZE; <1>

    @Nonbinding <2>
    int limit() default 0;

}
----
<.> We are defining a constant which we are later going to use later for our implementation.

<.> The `@Nonbinding` annotation tells CDI not to compare the value, that might be set to it, with the annotation, which the producer will expect.
If this annotation is not present, our producer would not work, as it will try to search for matching annotation that has `@Gold(limit = 2)` annotation for example.

Now it's time to go back to the `AdvertiserProducer` and implement the methods.

[source,java]
----
public class AdvertiserProducer {

    @Gold <1>
    @Produces <2>
    @Dependent <3>
    public List<Advertiser> produceGoldAdvertisers(InjectionPoint ctx) {
        var limit = ctx.getAnnotated().getAnnotation(Gold.class).limit(); <4>
        return getAdvertisers(Gold.SPONSOR_PACKAGE, limit);
    }

    @Silver <1>
    @Produces <2>
    @Dependent <3>
    public List<Advertiser> produceSilverAdvertisers(InjectionPoint ctx) {
        var limit = ctx.getAnnotated().getAnnotation(Silver.class).limit(); <4>
        return getAdvertisers(Silver.SPONSOR_PACKAGE, limit);
    }

    @Bronze <1>
    @Produces <2>
    @Dependent <3>
    public List<Advertiser> produceBronzeAdvertisers(InjectionPoint ctx) {
        var limit = ctx.getAnnotated().getAnnotation(Bronze.class).limit(); <4>
        return getAdvertisers(Bronze.SPONSOR_PACKAGE, limit);
    }

    private List<Advertiser> getAdvertisers(SponsorPackage sponsorPackage, int limit) {
        var query = Advertiser.<Advertiser>find("sponsorPackage = ?1", sponsorPackage);
        if (limit > 0) {
            query = query.page(0, limit);
        }

        return query.list();
    }

}
----
<.> We use our qualifier annotation to help CDI choose which method to call.
This is mandatory, when there's more than one option to provide instance of a class.

<.> This annotation tells CDI that this is a producer method.
It is invoked when the annotation above is used with `@Inject` within the definition of a CDI managed class.
+
CAUTION: When you import `@Produces`, be sure to check the package, you are importing from.
It should be either `javax.enterprise.inject.Produces` or `jakarta.enterprise.inject.Produces`.
You must be careful not to confuse it with `javax.ws.rs.Produces`/`jakarta.ws.rs.Produces`, as you already know that this annotation is used to describe the return type for JAX-RS, which has nothing to do with CDI producers.

<.> Each producer method should have a scope, so CDI can decide what instance to create for the injection point.
The reason we use `@Dependant` scope here is because in order to be able to get the data of that injection point, hence the name of the parameter `InjectionPoint`, we need to have this scope on our producer.

<.> We are able to read the current value of the annotation of the injection point.
You will see in the example below how we can use it later.

Now that our provider is implemented, we can add it to the `ArticleDecorator` class like that:

[source,java]
----
@Decorator
public abstract class ArticleDecorator implements ArticleService {

    @Inject
    @Delegate
    ArticleService articleService;

    @Inject <.>
    @Gold(limit = 10) <.>
    List<Advertiser> goldAdvertisers;

    @Override
    public Optional<Article> getArticle(long articleId) {
        return articleService.getArticle(articleId)
                .map(this::decorateArticle);
    }

    private Article decorateArticle(Article article) {
        var message = String.format("\nThis article has been sponsored by: %s",
                goldAdvertisers.stream().map(a -> a.name).collect(Collectors.joining(", "))); <.>
        var decoratedArticle = new Article(article.title, article.content + message, article.author);
        decoratedArticle.id = article.id;
        return decoratedArticle;
    }
}
----
<.> When we want to call a producer, engaged with an annotation, we always use the `Inject` annotation.
This is the way CDI will know what to look for.
<.> As we defined, we can optionally set a limit to our results.
So when it comes to the execution of the producer, it will take this value into account.
<.> When it comes to the implementation of the decorator, we can use the instance of `goldAdvertisers` as any other object ot type list.
We rely that CDI has successfully produced the data required.

==== Alternatives

When going through different implementations of the same class, there will be a point where you will need to create more than just one implementation.
In this type of scenario, you will need to use the power of alternatives.
The most common scenario where you will need an alternative will be within a test environment.

For example if you have a service which requires external actions such as contacting remote service or executing actions, depending on real live environments, such as payment service, which needs to connect to a payment provider.
When you need to test that service you could create an alternative implementation, annotating it with `@Alternative`, which mocks the invocation of the real instance.
To find our more about alternatives, https://www.baeldung.com/java-ee-cdi#5-the-default-and-alternative-annotations[read this article].

=== Events and Observers

In our final feature of CDI, we are going to talk about Events and Observers.
With CDI, you can achieve event-driven development, while implementing the event-observer pattern into you code.
Let's see an example, how we can achieved this in our code.

When a subscriber wants to extend their subscription, we usually need to charge them some amount of money in order to allow them to keep using our magazine manager.
In order to do so, we will need to create some form of subscription resource.
And that's what we are going to do...

- Create the class `subscription.SubscriptionResource`
- Add endpoints, such as:
* `PUT /subscription/{userId}` - adds/updates payment method to the subscriber
* `POST /subscription/{userId}` - updates subscriber's subscription for a certain period
- Create a `PaymentService, which is going to process payments`

At the end you should have something like this:

[source,java]
----
@RequestScoped
@Path("subscription")
public class SubscriptionResource {

    @Inject
    PaymentService paymentService;

    @PUT
    @Transactional
    @Path("{userId}")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response addPaymentMethod(@PathParam("userId") Long userId, CreditCardDTO creditCardDTO) {
        if (userId == null || userId < 0) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        if (creditCardDTO.getType() == null || creditCardDTO.getNumber() == null) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        CreditCard creditCard = new CreditCard(creditCardDTO.getNumber(), creditCardDTO.getType());
        return Subscriber.<Subscriber>findByIdOptional(userId)
                .stream().peek(s -> s.creditCard = creditCard)
                .findFirst().map(s -> Response.status(Response.Status.NO_CONTENT).build())
                .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build());
    }

    @POST
    @Path("{userId}")
    public Response chargeSubscriber(@PathParam("userId") Long userId) {
        if (userId == null || userId < 0) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        return Subscriber.<Subscriber>findByIdOptional(userId)
                .map(paymentService::chargeSubscriber)
                .map(result -> result? Response.status(Response.Status.NO_CONTENT).build() : Response.status(Response.Status.NOT_ACCEPTABLE).build())
                .orElseGet(() -> Response.status(Response.Status.NOT_FOUND).build());
    }
}

@ApplicationScoped
public class PaymentService {

    private static final Logger LOGGER = Logger.getLogger(PaymentService.class.getName());

    boolean chargeSubscriber(Subscriber subscriber) {
        if (subscriber.creditCard != null) {
            LOGGER.log(Level.INFO, "Charging subscriber with id: {0}  and card type {1} of number: {2}",
                    new Object[]{subscriber.id, subscriber.creditCard.creditCardType, subscriber.creditCard.number});

            return true;
        }

        return false;
    }

}
----

Here we are not going to implement the real thing, let's say that we just check if the user has credit card linked, and we log that we have charged them.
As you can see we don't have the most important part of the subscription renewal - updating the expiration date.
In practice some actions such as renewing a subscription would trigger more than one operation in action. For example you need to update the user's subscription expiration date, send email to the user with confirmation and receipt, send notification to the manager that a user has renewed their subscription, and so on.
 +
We can't put all of these side operations into the `chargeSubscriber()` method.
It would kill the purpose of the name of this method, which is to only charge the subscriber.
It doesn't say email subscriber, extend expiration to the subscriber, notify that person & etc.
Those type of side actions occur upon a certain event.
And CDI offers a way to handle events occurring outside the scope of the `chargeSubscriber` method.

First create an annotation, called `@ChargedSubscriber` in the subscription package:

[source,java]
----
@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface ChargedSubscriber {
}
----

Then let's add couple of handlers which are going to handle this event.

[source,java]
----
public class SubscriptionExtensionHandler {

    private static final Logger LOGGER = Logger.getLogger(SubscriptionExtensionHandler.class.getName());

    @Transactional
    @ActivateRequestContext <1>
    public void observeSubscriptionExtension(@Observes @ChargedSubscriber Subscriber subscriber) { <2>
        subscriber.subscribedUntil = subscriber.subscribedUntil.plusYears(1);
        LOGGER.log(Level.INFO, "Extended subscription for user {0}, till {1}",
                List.of(subscriber.id, subscriber.subscribedUntil.toString()).toArray());
    }

    public void sendEmail(@Observes @ChargedSubscriber Subscriber subscriber) { <2>
        LOGGER.log(Level.INFO, "Sent email to subscriber {0}, about their subscription renewal.", subscriber.id);
    }

}
----
<.> Events might get invoked outside a request context.
The request context is fired upon request and transactional methods can run only within it, meaning that if the context is not present, `@Transactional` may not work.
To make sure that we are running in a `@Transactional` method, we need to add `@ActivateRequestContext` annotation, which will ensure the request context on the

<.> With the `@Observes` annotation we are signalling CDI to listen for the occurrence ot an event being fired.
Then we use our newly made annotation, which specifies in which scenarios those methods should be invoked.
The object we pass as an argument, also known as the event payload, is the object we are expecting to get when the event is fired.

NOTE: Making the annotation for an event is optional.
You could create events and fire them without annotation, but in this occasion you may also fire event listeners which you might not know of, that also are listening for that event.

Next in order to fire those events upon making a payment, we need to update our payment service.

[source,java]
----
@ApplicationScoped
public class PaymentService {

    private static final Logger LOGGER = Logger.getLogger(PaymentService.class.getName());

    @Inject <.>
    @ChargedSubscriber <.>
    Event<Subscriber> onSubscriberCharged; <.>

    boolean chargeSubscriber(Subscriber subscriber) {
        if (subscriber.creditCard != null) {
            LOGGER.log(Level.INFO, "Charging subscriber with id: {0}  and card type {1} of number: {2}",
                    new Object[]{subscriber.id, subscriber.creditCard.creditCardType, subscriber.creditCard.number});

            onSubscriberCharged.fire(subscriber); <.>
            return true;
        }

        return false;
    }

}
----

<.> As any other CDI managed dependency, in order to signal the server that this property is CDI managed, we need to use the `@Inject` annotation.
<.> To deffer which type of event handlers we are going to call, we add our annotation here.
It's important to mention that if we do not add the annotation, our handlers won't get called.
<.> The we define our event with the type of payload we are going to pass. Here we use `javax.enterprise.event.Event` or `jakarta.enterprise.event.Event`, depending on your flavour of enterprise edition of Java.
<.> To fire the event, we simply call the `.fire()` method, passing the instance of our payload.

Let's test that and see the results with a user we previously created.

[source,curl]
----
curl --location --request POST 'http://localhost:8080/subscription/7'
----

Now it you look at the logs, you will find the following:

[source,log]
----
2022-09-27 13:23:18,965 INFO  [com.vid.mag.sub.PaymentService] (executor-thread-0) Charging subscriber with id: 7  and card type VISA of number: 3698521479
2022-09-27 13:23:18,973 INFO  [com.vid.mag.sub.SubscriptionExtensionHandler] (executor-thread-0) Extended subscription for user 7, till 2025-01-12
2022-09-27 13:23:18,973 INFO  [com.vid.mag.sub.SubscriptionExtensionHandler] (executor-thread-0) Sent email to subscriber 7, about their subscription renewal.
----

Now this is great, and it seems that the order of invocations are working as expected, but what if we want to flip things around?
What if we want to first send an email to the user, then update the entity?
 +
This could be done with the `@javax/jakarta.annotation.Priority` annotation:

[source,java]
----
    @Transactional
    @ActivateRequestContext
    public void observeSubscriptionExtension(@Priority(Priorities.APPLICATION + 2000) @Observes @ChargedSubscriber Subscriber subscriber) {
        subscriber.subscribedUntil = subscriber.subscribedUntil.plusYears(1);
        LOGGER.log(Level.INFO, "Extended subscription for user {0}, till {1}",
                List.of(subscriber.id, subscriber.subscribedUntil.toString()).toArray());
    }

    public void sendEmail(@Priority(Priorities.APPLICATION + 1000) @Observes @ChargedSubscriber Subscriber subscriber) {
        LOGGER.log(Level.INFO, "Sent email to subscriber {0}, about their subscription renewal.", subscriber.id);
    }
----

- `APPLICATION` priority, marks the priority of invocations of interceptors, defined by user applications.
When defining a priority, it is recommended to start with that priority.
- Setting the priority will be a sum of a number and that `APPLICATION` priority value (5000).
The method lower priotity will be executed first.

=== Conclusion

This concludes the basics of using CDI within Quarkus.
In the next chapter, we are going to get rid of all those checks on requests, by implementing bean validation.