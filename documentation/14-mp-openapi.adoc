:imagesdir: img

== Implementing OpenAPI documentation using MicroProfile OpenAPI

=== What is OpenAPI?

Our web applications do a lot of things.
So much so, that we need to document every endpoint we implement to remember it is there and how to use it.
Web applications don't work on their own.
They need developers to implement web clients, such as front-end applications or other web applications, will communicate with our web servers.
If we want a member of our development team to implement web page interface for our application, or allow other developers, outside our company to use our services APIs, we need to document our endpoints somewhere and share them.
 +
Apparently the developer will use the documentation to better understand our APIs, how to call them and what to expect as a response.
In ancient times everybody used to write their own documentation in their own style and format.
This approach has a few drawbacks, however.
You have to spend the time to write and style your documentation, update it every time you change something, and it is not interoperable, meaning that your documentation format is unique to your application.
Also, when the application grows bigger you'll start putting less effort into updating that documentation, making it obsolete, and one day you'll have to spend a lot of time, checking that it is up-to-date.

Nowadays, there is a more modern solution to this concern.
OpenAPI is here to do the job, by creating a standardized way to write API documentations, export them in yaml, and share them to other developers, who are going to implement your webhooks or endpoints either by hand or even automatically.
There are https://openapi-generator.tech[plugins and tools] that can generate endpoints based on an OpenAPI file.
And that's the magic of it.
Now when you want to give out documentation of your REST endpoints, you can simply pass them a yaml file, which they can auto-generate into a working code in their programming language.

With the power of MP OpenAPI, you get the ability to generate your openapi yaml and instantly keep it up to date, by using, you guessed it - annotations.
You can also use the integrated Swagger UI to visualise and interact with your web application, without having to implement any front-end components for that purpose.

=== Integrating OpenAPI plugin into our application

To get started with our openapi documentation, we simply need to add yet another quarkus plugin in our `pom.xml`:

[source, xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-smallrye-openapi</artifactId>
</dependency>
----

TIP: Don't be shy.
You may add this plugin to all your Quarkus applications.

Now you can start your projects and go to `http://localhost:<prot>/q/openapi`.
Your browser may ask you to download a yaml file, containing all the specified endpoints we created throughout this course.
And the Swagger part - if you go to `/q/swagger-ui/`, you will see a handy user interface that you may start using directly to fiddle with your application.
As previously mentioned this yaml file can be used by you and other developers to implement webhooks that can call your endpoints in their applications.

> But wait... we are not finished yet.

=== Using the MP OpenAPI annotations

Let's have a look at the Swagger UI page, that was generated by introducing our plugin:

image::swagger-initial.png[align=center]

It looks pretty hollow.
We know there are different type of resources, that contain different type of endpoints, but we don't know what they are meant for and how to use them.
Here comes the part with the annotations.
We will use MP OpenAPI's annotations to better describe how our endpoints work.
To start with the most obvious, let's first document our Article resource.

==== The `@Tag` annotation

We want to tell the readers of our documentation that Article resource is the section of endpoints responsible for maintaining articles on the platform.
To do this, we need to annotate the whole class `ArticleResource` with `@Tag` and provide the needed attributes:

[source, java]
----
//imports
import org.eclipse.microprofile.openapi.annotations.tags.Tag;

@Authenticated
@RequestScoped
@Path("/article")
@Tag(name = "Article Resource", description = "Contains all the endpoints, required to create, update and delete articles.")
public class ArticleResource {
    //implementation
}

----

Now if we reload the  Swagger UI page, we are going to see that updated.

image::article-resource-swagger-title.png[align=center]

Great job! Now we have made the first step into making our documentation more understandable.
Remember that this will also reflect into our openapi.yml file.

==== The `@Operation` annotation

Once we have the resource description out of the way, we might need to give a better description of our endpoints.
This can simply be done by adding the `@Operation` annotation to each method, within the resource:

[source, java]
----
public class ArticleResource {

    @POST
    @Transactional
    @RolesAllowed({Author.ROLE_NAME})
    @Consumes(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "createArticle",
            summary = "Create article",
            description = "Creates an article"
    )
    public Response createArticle(@Valid @NotNull ArticleDTO articleDTO) {
        //code
    }

    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "getArticle",
            summary = "Get article",
            description = "Gets article by its id"
    )
    public Response getArticle(@Positive @PathParam("id") Long articleId) {
        //code
    }

    @PUT
    @Transactional
    @Path("/{id}")
    @RolesAllowed({Author.ROLE_NAME})
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "editArticle",
            summary = "Edit article",
            description = "Updates an article by its id"
    )
    public Response editArticle(@Positive @PathParam("id") Long articleId, @Valid @NotNull ArticleDTO articleDTO) {
        // code
    }

    @DELETE
    @Transactional
    @Path("/{id}")
    @RolesAllowed({Author.ROLE_NAME, Manager.ROLE_NAME})
    @Operation(
            operationId = "deleteArticle",
            summary = "Delete article",
            description = "Removes an article and its related comments by its id"
    )
    public void deleteArticle(@Positive @PathParam("id") Long articleId) {
        //code
    }

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "getArticles",
            summary = "Get articles",
            description = "Returns a list of articles. Can be filtered by author's id"
    )
    public Response getArticles(@QueryParam("page") @DefaultValue("1") @Positive int page,
                                @QueryParam("size") @DefaultValue("10") @Positive int size,
                                @QueryParam("author") @Positive Long authorId) {
        //code
    }

    @PATCH
    @Transactional
    @RolesAllowed({Manager.ROLE_NAME})
    @Path("{id}/advertiser/{advertiserId}")
    @Operation(
            operationId = "addAdvertiserToArticle",
            summary = "Promote article",
            description = "Adds advertiser to the article"
    )
    public Response addAdvertiserToArticle(@Positive @PathParam("id") Long id, @Positive @PathParam("advertiserId") Long advertiserId) {
        //code
    }
}
----

Now if we refresh the page again, we should see our descriptions:

image::article-resource-swagger-operation-annotation.png[align=center]

And if we open an entry, we will see our description:

image::article-swagger-ui-full-description.png[align=center]

==== The `@Parameter` annotation

So, you opened the "Get articles" tab, and you are met with a small form, allowing you to add in author, page and size.

image::get-article-swagger-ui-parameters.png[align=center]

Despite it being self-explanatory, one might want to read more information about these properties, get an example of what value they should contain or what are its limitations.
From what our openapi plugin generated, we can see that that is not the case here.
We will change that with the `@Parameter` annotation.
You can place that either next to the parameter in the method's signature or on the level of the method.

[source, java]
----
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "getArticles",
            summary = "Get articles",
            description = "Returns a list of articles. Can be filtered by author's id"
    )
    @Parameter(
            name = "author", <.>
            in = ParameterIn.QUERY, <.>
            description = "Filter articles by author id. If empty, will return all articles",
            example = "123"
    )
    public Response getArticles(
            @Parameter(required = true, description = "Search result page, starts from 1") <3>
@QueryParam("page") @DefaultValue("1") @Positive int page,
                                @Parameter(required = true, description = "Size of the search result page. Cannot be 0") <3>
@QueryParam("size") @DefaultValue("10") @Positive int size,
                                @QueryParam("author") @Positive Long authorId) {
    //code
                                }
----
<.> When using parameter annotation on method level, you must refer to the name matching that parameter, in order to help MP find the relation between your documented parameter and the parameter itself.
<.> It is also important to state where that parameter is, otherwise the documentation will not show up
<.> When using the `@Parameter` annotation on attribute level, you don't need to state the name or the place of the parameter, unless you want to achieve some kind of custom result.
You can simply add the description and other attributes that need to be explicitly added.

Now when we look at our Get Articles tab, we will see a more descriptive view:

image::get-article-resource-swagger-ui-parameters-edited.png[align=center]

==== The `@APIResponses` annotation

The next thing we can see incomplete in our "Get articles" endpoint are the responses.
They don't tell the whole story.
Let's go and fix that.

[source, java]
----
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            //attributes
    )
    @APIResponses({
            @APIResponse(
                    responseCode = "200",
                    name = "List of articles",
                    description = "The articles that were found",
                    content = @Content( <.>
                            schema = @Schema(name = "ArticleDTO", <.>
                                    implementation = ArticleDTO[].class,
                                    description = "List of found articles, filtered by author (if provided).",
                                    example = """
                                            [
                                               {
                                                   "authorId": 1,
                                                   "content": "The quick brown fox runs over the lazy dog.",
                                                   "id": 3,
                                                   "publishDate": "2022-01-12T00:00",
                                                   "title": "Article for the soul."
                                                 },
                                                 {
                                                   "authorId": 1,
                                                   "content": "This is an article by the same author, who created Ipsum Lorem",
                                                   "id": 4,
                                                   "publishDate": "2022-02-12T00:00",
                                                   "title": "The aitor that created"
                                                 },
                                                 {
                                                   "authorId": 2,
                                                   "content": "This is how I got my hands into Java long time ago. Long article here...",
                                                   "id": 5,
                                                   "publishDate": "2020-01-10T00:00",
                                                   "title": "The way I became Java developer"
                                                 },
                                                 {
                                                   "authorId": 2,
                                                   "content": "This is my extreme enjoyment of Quarkus, written in an article",
                                                   "id": 6,
                                                   "publishDate": "2022-09-13T00:00",
                                                   "title": "I love Quarkus and Quarkus loves me back"
                                                 }
                                            ]
                                            """
                            )
                    )
            ),
            @APIResponse(
                    responseCode = "400",
                    name = "Bad Request",
                    description = "You provided malformed query parameters. Check the requirements and try again."
            ),
            @APIResponse(
                    responseCode = "401",
                    name = "Unauthorized",
                    description = """
                    You need to provide Bearer token in the authentication header or your token has expired.
                    Generate a new token, using the Login resource
            """
            ),
            @APIResponse(
                    responseCode = "403",
                    name = "Not allowed",
                    description = """
                            The user you are accessing this endpoint with, has no permission to access it.
                            """
            )
    })
    @Parameter(
            // attributes
    )
    public Response getArticles() {
    }
----
<.> With the `@Content` annotation we tell our generator what the response object will be, if there is any
<.> The `schema` attribute and annotation allow us to point to an object that we are going to return.
If the object is POJO, the generator will try to generate an example, based on the expected JSON, but if that is not sufficient, we can fill in an `example` by providing value to the respective attribute.

Now we can refresh the page and see the results:

image::get-article-responses.png[align=center]

In the next step we are going to dwell into that `@Schema` annotation.

==== The `@Schema` annotation

This annotation has a bit more capabilities than just providing a reference to a class.
We can use it to describe the fields in that class.
If you click on the "Schema" tab, next to "Example value", you will see description of each attribute of the response object is insufficient:

image::get-article-schema-initial.png[align=center]

Furthermore, if we open the "Create article" tab, we will see a very bad example of what an article input should look like:

image::create-article-schema-initial.png[align=center]

We can fix that, by using the `@Schema` annotation on each object and attribute we want to customize.

In `ArticleDTO`...

[source, java]
----
@Schema(description = "Contains data about the article")
public class ArticleDTO {

    @Schema(description = "The id of the article", example = "1234")
    private Long id;

    @NotBlank
    @Schema(description = "The title of the article", example = "The quick brown fox jumps over the lazy dog!")
    @Size(min = 1, max = 225, message = "The title of the article must be between {min} and {max} characters")
    private String title;

    @NotBlank
    @Schema(description = "The article's content.", example = "This is a long article about a quick fox that is brown and jumps over a lazy dog that is lazy")
    @Size(min = 1, max = 10_000)
    private String content;

    @Schema(description = "The date when the article was published on.", example = "2022-09-13T00:00")
    private String publishDate;

    @Schema(description = "The date this article was last modified. Might differ from the publish date.", example = "2022-09-13T00:01")
    private String lastModified;

    @Schema(description = "The id of the author this article is written by.", example = "256")
    private Long authorId;

    @Schema(description = "Comments by article readers")
    private List<CommentDTO> comments;

    //getters, setters, constructors
}
----

and in `CommentDTO`:

[source, java]
----
@Schema(description = "A comment by any user left on an article")
public class CommentDTO {

    @Schema(description = "The id of the comment", example = "124")
    private Long id;

    @NotBlank
    @Size(max = 255)
    @Schema(description = "The comment's content", example = "I loved this article. It is true that dogs are lazy when foxes are quick.")
    private String content;

    @NotNull
    @Positive
    @Schema(description = "The id of the comment's author. Can be any type of user", example = "235")
    private Long authorId;

    @Schema(description = "The date when the comment was published", example = "2022-09-13T00:01")
    private String created;

    //getters, setters, constructors
}
----

Now if we refresh the page again, we will see those values updated.

image::article-schema-full.png[align=center]

And the automatic example in "Create article" should look a lot more clear:

image::create-article-example.png[align=center]

NOTE: Notice that we are using the same POJOs for creating an article and getting an article.
The auto generation of the example will use every value that it finds within the object, despite that we don't accept comments.
You can always use the `example` attribute to provide a more accurate example.

=== Extracting our OpenAPI endpoints

With all the new annotations, what you may have noticed is that our resources have less visible and readable code, but more annotations that cause misalignment of the code and obstruct its readability.

We can fix that by simply defining interfaces where we will place our OpenAPI annotations and constraint validations and leave the implementation in its own class.
The simplest way to do this for every resource class you have it to use the power of your IDE.
Here's how it's done in IntelliJ:

. Right click on the resource class and select *Refactor* -> *Extract Interface...*
+
image::extract-interface.png[align=center]

. A window will open, where you need to define your preferences
+
image::article-resource-preferences-extraction.png[align=cetner]
+
NOTE: Make sure to select all the methods that are entry point of an endpoint and select *Move* on the JavaDoc option to ger all your OpenAPI annotations inside the interface.

. When this is done, make sure that all the annotations are copied over to the interface.

At the end you should have an interface looking like this:

[source, java]
----
@Path("/article")
@Tag(name = "Article Resource", description = "Contains all the endpoints, required to create, update and delete articles.")
public interface ArticleAPI {
    @POST
    @RolesAllowed({Author.ROLE_NAME})
    @Consumes(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "createArticle",
            summary = "Create article",
            description = "Creates an article"
    )
    Response createArticle(@Valid @NotNull ArticleDTO articleDTO);

    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "getArticle",
            summary = "Get article",
            description = "Gets article by its id"
    )
    Response getArticle(@Positive @PathParam("id") Long articleId);

    @PUT
    @Path("/{id}")
    @RolesAllowed({Author.ROLE_NAME})
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "editArticle",
            summary = "Edit article",
            description = "Updates an article by its id"
    )
    Response editArticle(@Positive @PathParam("id") Long articleId, @Valid @NotNull ArticleDTO articleDTO);

    @DELETE
    @Path("/{id}")
    @RolesAllowed({Author.ROLE_NAME, Manager.ROLE_NAME})
    @Operation(
            operationId = "deleteArticle",
            summary = "Delete article",
            description = "Removes an article and its related comments by its id"
    )
    void deleteArticle(@Positive @PathParam("id") Long articleId);

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Operation(
            operationId = "getArticles",
            summary = "Get articles",
            description = "Returns a list of articles. Can be filtered by author's id"
    )
    @APIResponses({
            @APIResponse(
                    responseCode = "200",
                    name = "List of articles",
                    description = "The articles that were found",
                    content = @Content(
                            schema = @Schema(name = "ArticleDTO",
                                    implementation = ArticleDTO[].class,
                                    description = "List of found articles, filtered by author (if provided).",
                                    example = """
                                            [
                                               {
                                                   "authorId": 1,
                                                   "content": "The quick brown fox runs over the lazy dog.",
                                                   "id": 3,
                                                   "publishDate": "2022-01-12T00:00",
                                                   "title": "Article for the soul."
                                                 },
                                                 {
                                                   "authorId": 1,
                                                   "content": "This is an article by the same author, who created Ipsum Lorem",
                                                   "id": 4,
                                                   "publishDate": "2022-02-12T00:00",
                                                   "title": "The aitor that created"
                                                 },
                                                 {
                                                   "authorId": 2,
                                                   "content": "This is how I got my hands into Java long time ago. Long article here...",
                                                   "id": 5,
                                                   "publishDate": "2020-01-10T00:00",
                                                   "title": "The way I became Java developer"
                                                 },
                                                 {
                                                   "authorId": 2,
                                                   "content": "This is my extreme enjoyment of Quarkus, written in an article",
                                                   "id": 6,
                                                   "publishDate": "2022-09-13T00:00",
                                                   "title": "I love Quarkus and Quarkus loves me back"
                                                 }
                                            ]
                                            """
                            )
                    )
            ),
            @APIResponse(
                    responseCode = "400",
                    name = "Bad Request",
                    description = "You provided malformed query parameters. Check the requirements and try again."
            ),
            @APIResponse(
                    responseCode = "401",
                    name = "Unauthorized",
                    description = """
                                    You need to provide Bearer token in the authentication header or your token has expired.
                                    Generate a new token, using the Login resource
                            """
            ),
            @APIResponse(
                    responseCode = "403",
                    name = "Not allowed",
                    description = """
                            The user you are accessing this endpoint with, has no permission to access it.
                            """
            )
    })
    @Parameter(
            name = "author",
            in = ParameterIn.QUERY,
            description = "Filter articles by author id. If empty, will return all articles",
            example = "123"
    )
    Response getArticles(@Parameter(required = true, description = "Search result page, starts from 1") @QueryParam("page") @DefaultValue("1") @Positive int page,
                         @Parameter(required = true, description = "Size of the search result page. Cannot be 0") @QueryParam("size") @DefaultValue("10") @Positive int size,
                         @QueryParam("author") @Positive Long authorId);

    @PATCH
    @RolesAllowed({Manager.ROLE_NAME})
    @Path("{id}/advertiser/{advertiserId}")
    @Operation(
            operationId = "addAdvertiserToArticle",
            summary = "Promote article",
            description = "Adds advertiser to the article"
    )
    Response addAdvertiserToArticle(@Positive @PathParam("id") Long id, @Positive @PathParam("advertiserId") Long advertiserId);
}
----

After you've done so, go over `ArticleResource` class and remove every annotation that is present in the newly created interface.
At the end the class should look like this:

[source, java]
----
@RequestScoped
public class ArticleResource implements ArticleAPI {

    @Inject
    ArticleService articleService;

    @Inject
    @LoggedUser
    User loggedUser;


    @Override
    @Transactional
    public Response createArticle(ArticleDTO articleDTO) {
        //implementation
    }


    @Override
    public Response getArticle(Long articleId) {
        //implementation
    }


    @Override
    @Transactional
    public Response editArticle(Long articleId, ArticleDTO articleDTO) {
        //implementation
    }


    @Override
    @Transactional
    public void deleteArticle(Long articleId) {
        //implementation
    }


    @Override
    public Response getArticles(int page, int size, Long authorId) {
        //implementation
    }


    @Override
    @Transactional
    public Response addAdvertiserToArticle(Long id, Long advertiserId) {
        //implementation
    }
}
----

Pretty neat, huh?

=== Securing the OpenAPI documentation

OpenAPI can be very useful tool, but our current configuration has a bit of a security issue.
If we don't want to share our APIs publicly, but just internally, we might not want users to be able to call `/q/openapi` and download and exploit our APIs.
This is why we can prevent this from happening.

By default, when you run quarkus in *prod* mode (directly run the application jar or set `quarkus.profile=prod`), quarkus will turn off the Swagger-ui page, but this will not disable the generation of the openapi file.
To disable that, you can simply add `%prod.quarkus.smallrye-openapi.enable=false` into the application.properties file and recompile the application.

TIP: There is also another way to secure your OpenAPI endpoints, by using authentication methods or even configure the paths of the documents.
You can read the full configuration reference in https://quarkus.io/guides/openapi-swaggerui#configuration-reference[the official Quarkus article].

=== Conclusion

MP OpenAPI has a couple of more annotations which are not so mandatory, but can help you to achieve more capabilities with your yaml generation.
You can always refer to the official documentation to find out how to do more stuff and achieve different results.
Here are some useful links to look at:

- The official MP OpenAPI documentation - https://download.eclipse.org/microprofile/microprofile-open-api-1.0/microprofile-openapi-spec.html
- Another tutorial on documenting your applications using MP OpenAPI - https://openliberty.io/guides/microprofile-openapi.html

TIP: While at it, why don't you go through every endpoint in your applications and refactor them to look prettier in OpenAPI?
Come on! It will be fun!