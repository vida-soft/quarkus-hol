:imagesdir: img

== Java Persistence API (JPA)

One of the core functions of an application server is being to work with a database.
Functions as extracting data from the database, adding or removing data on demand are crucial to all business oriented web applications.

We'll continue our journey into building a magazine manager web application with setting up its data model.
The standard way to do that and to then persist the modelled data is with the Java Persistence API (JPA).

.JPA Terminology
*****************************************
*Entity* - A non-final plain old Java object (POJO) with a non-argument constructor. It represents a database table with its member variables representing the table columns.

*Persistence context*, *EntityManager* - Both terms mean one and the same thing. It is the interface that you use to load and store entities from and to the database. It acts also as a first level cache for your application.

*Persistence unit*, *EntityManagerFactory* - The factory which you use to obtain the entity manager. There you configure the way to connect to the database - a server datasource or direct JDBC properties.

*JPQL* - Object-oriented query language, based on SQL. It works on objects and their fields, rather than on tables, columns and relationships.
*****************************************

As a start we will need to add the proper configurations and extensions to make our project work with a database.

=== Adding extensions to support JPA

As we mentioned in the beginning, our project will include only the stuff we need, and right now although we have annotations for JPA, they won't work, without the implementations, required to run them. 

In order to work with a database, we will need to add a couple more extensions to our project:

- *quarkus-hibernate-orm* - will allow to use Hibernate's JPA implementation.
- *quarkus-jdbc-h2* - the database driver, used to communicate with the database using Hibernate's APIs

NOTE: We'll use H2 as embedded database in this installment of our series.

To add extensions to quarkus, simply execute the following command in the terminal:

[source,shell]
----
mvn quarkus:add-extension -Dextensions="io.quarkus:quarkus-hibernate-orm, io.quarkus:quarkus-jdbc-h2"
----

Now if you open `pom.xml`, you'll see that we have two new dependencies added to the list:

[source,xml]
----
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-jdbc-h2</artifactId>
    </dependency>

    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-hibernate-orm</artifactId>
    </dependency>
----

=== Adding configuration to the database

Having just the extensions added, won't help the project communicating with the database.
We also need to point it to where and what the database is.
To do so, we are going to add some properties into our `/src/main/resources/application.properties` file.

[source,properties]
----
# configure your datasource
quarkus.datasource.db-kind = h2
quarkus.datasource.username = sarah
quarkus.datasource.password = connor
quarkus.datasource.jdbc.url = jdbc:h2:file:./data/magman;DB_CLOSE_DELAY=-1

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation = drop-and-create
quarkus.hibernate-orm.log.sql=true
----

NOTE: Depending on the database, your configuration might vary.
In a real world scenario, you will need to configure database username and password or set a different type of generation mechanism.
You can view other examples for database configuration https://quarkus.io/guides/hibernate-orm-panache[here].

=== The database model

Now that we have our database configured, let's upgrade our project by creating our database model.
For that purpose, we are going to follow the diagram below.

image::db-model.jpg[align=center]

First off, create a new package, named `model` under `com.vidasoft.magman`.
This will help us separate our database ORM layer from the rest of the project.
Then, let's build the core classes for the database:

[source,java]
----

public class User {
    ...
}

public class Article {
    ...
}

public class Comment {
    ...
}

public class Advertiser {
    ...
}
----

After that's been done, let's start shaping our model classes...

=== Defining object-relational mapping with JPA 

NOTE: Depending on the version of Java you use, the following annotations could be found either in packages `jakarta.persistence` or `jakarta.persistence`.

Starting off with the User class, the first and most important thing we'll need to set is the annotation `@Entity`.
This is an annotation, telling JPA, that this class is used in relation with a database table.

[source,java]
----
@Entity
@Table(name = "Users") <.>
public class User {}
----
<.> Here we are also adding an optional annotation defining the name of the table.

NOTE: In most databases the word "user" is reserved to the language, as it refers to the user of the database and not some name of a table.
Therefore you should avoid using the name "user" for a table.

TIP: Sometimes you will have to model your Java objects or tables, based on an already existing database.
Usually JPA will match the name of tables and columns by their Java names, but in the case where the database already exists, names might not be exactly the same.
 +
For example you might have a table, named `CUSTOMER_USERS`, but you want to map it to a class called `User`.
To address that, you'll need to use the `@Table` annotation and set the name to the table name, related.
 +
The same thing can be done for the columns, using the `@Column` annotation.

Next important thing is to define a property for `id`, which will be our primary key to the database.

[source,java]
----
public class User {

    @Id <.>
    @GeneratedValue(strategy = GenerationType.AUTO) <.>
    public long id;
}
----
<.> `Id` annotation tells JPA that this property maps the id column of the table. 
<.> `GeneratedValue` is an annotation, that tells Hibernate how to handle id generation for new entities.
In this example `GenerationType.AUTO`, would tell Hibernate or any other ORM implementation to handle Id generation with its default setting four auto generation.
The most common approach is generating a database object, called sequence, which keeps track of the last id used and assign the next one to the entity.

NOTE: You may be tempted to encapsulate the properties with getters and setters, but hold on for a minute and think about why?
When we are trying to access/modify the properties of our variables, we are always going to get or set the exact values we want to assign, so using getters and setters is not necessary in such scenario.

One of the things we also need do decide during database modeling is how do we want the database to behave, when two or more people are trying to access it.
Do we want the access to be one user at a time, or do we want all users to have access at any time.
This decision is usually based on how strict we want to be on database integrity, and how crucial is that to the project.
The procedure we use to control that access is called locking.

.Optimistic vs pessimistic locking
*****************************************
When the access to the database is limited to one user at a time, we use the term *pessimistic locking*.
This means that when a user performs `SELECT`, `INSERT`, `UPDATE`, `DELETE`, etc. operations, other users are not allowed to access the database, and will have to wait for the initial operations to finish.
This type of locking guarantees that everyone is working with the most recent and up to date data and prevents conflicts, where two users might be editing the same table or column.

The other most commonly used method is called *optimistic locking*.
This type of locking relies that every table row has a specific column, that will keep track on the data's recency by versioning.
That way if two users edit the same data, the first one who's going to save it, prevents the others from overwriting it, by version comparison.
When the database has been modified, Hibernate will check the version of the persisted entity compare it against the version of the next modification wanting to be persisted.
If the new entity has a version lower than the version in the database, it won't be persisted and the transaction will be rolled back, meaning all changes, no matter their relation to that entity will be dismissed.
*****************************************

For our project we are going to use *optimistic locking*.
It is the most commonly used type of locking as it is sufficient enough to keep the data's integrity intact.

[source,java]
----
public class User {
    ...
    @Version <.>
    long version;
}
----
<.> With the `Version` annotation we tell our ORM that this is the field to compare when modifying data, to check whether we are working on an old invalid data or new one.

Now that we have that set, we have the bare minimum for creating object-relational mapping for our database.
We can go and add those fields to the other model classes OR there is a more neat solution to that.
If we copy-paste `id` and `version` fields to every class, we're avoiding one of the main principles of using an OOP language - abstraction.

To include abstraction and allow every entity to use the same fields, let's create the following class:

[source,java]
----
@MappedSuperclass <.>
public abstract class AbstractEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    public long id;

    @Version
    public long version;

}

@Entity
@Table(name = "Users")
public class User extends AbstractEntity {
    //id and version are shifted to AbstractEntity, so this class is empty now.
}
----
<.> `MappedSuperclass` is an annotation crucial for how we define abstractions in our ORM.
It tells Hibernate, that we are going to have these columns in every table.

.Abstraction in JPA
*****************************************
There are four types of entity abstraction and depending on the data model structure we have to work with, we get to choose which one is more appropriate to use:


- *MappedSuperclass* – the parent classes, can't have the `@Entity` annotation.
This approach will set all the columns of the superclass to the inheriting entities.
- *Single Table* – this approach will use one table for all inheriting entities.
Querying an entity, inheriting this class, will return only the columns regarding that entity.
- *Joined Table* – this will create one common table for all entities, containing the common properties.
Querying an entity, inheriting such a class, will create a join query.
- *Table per Class* – the resulting schema is similar to the one using `@MappedSuperclass`. But Table per Class will indeed define entities for parent classes, allowing associations and polymorphic queries as a result.

You can find more about ORM abstraction https://www.baeldung.com/hibernate-inheritance[here].
*****************************************

=== Modeling the rest of our entities

Now that we have the main objects for our database model, let's add all of their columns as properties to our classes.

==== The `User` class

For our project we are going to have three types of users:

. Author - will create and comment on articles
. Subscriber - will be able to read articles, add comments and subscribe to an Advertiser package.
. Manager - will have root access to the website and be able to control the application.

Just like the `AbstractEntity`, we're again facing another abstraction dilemma.
This time, instead of using `@MappedSuperclass`, we are going to use the Single table strategy.

[source,java]
----
@Entity
@Table(name = "Users")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) <.>
public class User extends AbstractEntity {...}

@Entity
public class Author extends User {}

@Entity
public class Subscriber extends User {}

public class Manager extends User {}
----
<.> With the `Inheritance` annotation, we're telling Hibernate how to treat this abstraction.
In the case of Single table, we can omit the annotation, as it is the default choice in JPA, when it comes to inheritance.
Here, we are using it, just to demonstrate how it is usually done.

Having the abstractions set, we're ready to fully define our `User` entity:

[source,java]
----
@Entity
@Table(name = "Users")
public abstract class User extends AbstractEntity {
    public String userName;
    public String password;
    public String firstName;
    public String lastName;
    public String email;
}
----

Now let's define the other three classes:

[source,java]
----
@Entity
public class Author extends User {
    public boolean isRegular;
    public int salary;
}

@Entity
public class Subscriber extends User {
    public String streetAddress;
    public LocalDate subscribedUntil;

    @Embedded <.>
    public CreditCard creditCard;
}

@Entity
public class Manager extends User {
    //This entity has no additional properties for now
}

----
<.> In the database properties from this class are stored in the same table.
Using the `Embedded` annotation helps us to achieve a `has-a` relationship, without creating an additional table to the database.

TIP: If you look at our database model at the beginning, you will see the column `DTYPE` for the `Users` table.
This is a column, generated automatically by the ORM, to tell what kind of user class the row is related to.
Its value can be either Author, Subscriber or Manager.

==== The `CreditCard` class

.The `@Embeddable` annotation
*****************************************
Just like abstraction, we get to choose what kind of composition we want, regarding to our ORM model.
We may have the database structured in one way, but want to use it in another.

In our example the credit card would typically be one-to-one relationship, and we would have two ways to build this relation in our object model

- Add one-to-one relationship, using `OneToOne` annotation.
This will add another table for the credit card entity.
- Create an embeddable object, which is going extend and bind columns of the same table (the `Users` table in our case).
This is used to allow a more object-oriented experience, in a scenario where the database is not modeled the same way.
*****************************************

To satisfy the `Subscriber` class, let's create the `Embeddable` `CreditCard`:

[source,java]
----
@Embeddable<.>
public class CreditCard {

    public static final CreditCard DEFAULT = new CreditCard("", CreditCardType.VISA);

    public String number;

    @Enumerated(EnumType.STRING)<.>
    public CreditCardType creditCardType;
}

public enum CreditCardType {

    VISA("Visa"), MASTER_CARD("MasterCard"), AMERICAN_EXPRESS("American Express");

    private String displayName;

    CreditCardType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() {
        return displayName;
    }
}

----
<.> Annotating a class with `Embeddable` annotation, means that it cannot be an `Entity`.
Therefore no table will be created for it.
Take it as an extension to another entity.
Other than that, it behaves like any other JPA class.
On the other side, where the embeddable class is going to be embedded, we just need to add the `@Embedded` annotation (just like we did in the `Subscriber` class).
It can contain relationships and have all types of annotations supported.
<.> The `Enumerated` annotation helps the ORM to define how this field is going to be shaped into a column.
There are two strategies:
 +
- `EnumType.STRING` (Recommended) - will persist the enum as varchar string. (e.g. `CreditCardType.VISA` would be persisted as `"VISA"`)
- `EnumType.ORDINAL` - will persist the enum as an integer, depending on the position of the enumerated value.

CAUTION: Using `EnumType.ORDINAL` is prone to bugs.
This is due to the nature those ordinals are assigned. If for example we have `VISA, MASTERCARD`, their ordinals would be `0, 1`, but if somebody swaps those, the order of the ordinals will remain the same.
This means that it is very easy to change the Credit card type by a mistake and the ORM will not be able to recognize that.
To avoid it, it is better to use `EnumType.STRING`.
 + 
When it comes to changing the name of the enum, it is better to get a runtime error, when casting that name to enum, than getting seemingly unrelated errors, due to switched enum order. 

==== The `Article` class

We are going to define the `Article` class as follows:

[source,java]
----
@Entity
public class Article extends AbstractEntity {
    public String title;

    @Column(length = 10_000) <.>
    public String content;

    public LocalDate publishDate;

    @ManyToOne <.>
    public Author author;

    @OneToMany <.>
    public List<Comment> comments = new ArrayList<>();
}
----
<.> Dy default varchar fields in databases are with a length of 255.
An article's content would probably contain a lot more characters than that.
With the `@Column` annotation we can define different length, suitable to store an article.
<.> Defines that one author has many articles
<.> Defines that one article has many comments

.The proper way to define relationships in ORM
*****************************************
The common way of mapping one-to-many or many-to-one relationships would be to have reference in both entities, meaning that `Article` should have many-to-one relationship with the `Author`, and the author should have one-to-many relationship with the `Article`.
This would mean that we would also need to add `List<Article> articles` to the `Author` entity, just like we're doing with the comments.

> But wait! That's not all!

We actually don't want to do that. 

And why?

Imagine the following scenario...

You want to get a list of all authors.
But along with that, you might also be getting the list of all of their articles.
This would add a lot of load to the database.
You want to get articles only when you need them, as much as you need of them.
With the one-to-many approach you are able to get all or none.
Imagine if the amount of articles is 1000 or more...

But why did we leave the one-to-many relationship for the comments?

Consider this relationship as one-to-*few*.
In our scenario when we ask for an Article, we would also be wanting all of its comments.

But there's more.
Loading child data, by default, is lazy, meaning that it will be queried only if it's needed. More of that, later in this chapter.

TIP: To learn more about why many-to-one is the better way to approach large 1:n relationships, you can also https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/[read this article here].

*****************************************

==== The `Comment` class

We're almost at the end of our data modeling.
Here is how our `Comment` class should look like:

[source,java]
----
@Entity
public class Comment extends AbstractEntity {

    public String content;

    @ManyToOne
    public User author;

    public LocalDateTime created;

}
----

Nothing particular to add here, let's move on.

==== The `Advertiser` class

This class will introduce advertisers or sponsors to our magazine.

[source,java]
----
@Entity
public class Advertiser extends AbstractEntity {

    public String name;

    public String website;

    public String contactEmail;

    @ManyToOne
    public Article article;

    @Lob <.>
    public byte[] logo;

    @Enumerated(EnumType.STRING)
    public SponsorPackage sponsorPackage;

}

public enum SponsorPackage {

    GOLD(1000), SILVER(500), BRONZE(100);

    private int price;

    SponsorPackage(int price) {
        this.price = price;
    }

    public int getPrice() {
        return price;
    }
}
----
<.> `Lob` is an annotation pointing that the data passed to the database will be of a binary type.
It is recommended to use primitive arrays here, because in memory they will keep all values in one array and will be faster to access.
Using wrapped object array, such as `Byte`, will add performance delay, as the references to the values will be scattered throughout the system's memory.

=== Putting our database into action

Now that we have our database model created, let's put it in use.
Starting with our previous topic, let's start saving our articles into the database.

To make things easy, we are going to change each endpoint one-by-one.

==== Preparing our articles for real use

As you saw in our database model all of our articles have authors.
One author has many articles, meaning that an article cannot and should not exist without an author.
This means that in order to create an article, we need an author to assign it to.
Let's use our JAX-RS knowledge from the previous chapter and create the class `user.AuthorResource`

[source,java]
----
@Path("/user/author")
public class AuthorResource {

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createAuthor(AuthorDTO authorDTO) {

    }

}
----

Along with that, we are going to need a transfer object for the author:

[source,java]
----
public abstract class UserDTO {

    private String userName;
    private String password;
    private String firstName;
    private String lastName;
    private String email;

    //getters and setters
}

public class AuthorDTO extends UserDTO {

    private boolean isRegular;
    private int salary;

    //getters and setters
}
----

And finally let's add constructors to our `User` and `Author` classes.
[source,java]
----
public abstract class User extends AbstractEntity {
    // properties

    public User() {
    }

    public User(String userName, String password, String firstName, String lastName, String email) { <1>
        this.userName = userName;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    }
}

public class Author extends User {
    //properties

    public Author() { <1>
    }

    public Author(String userName, String password, String firstName, String lastName, String email, boolean isRegular, int salary) {
        super(userName, password, firstName, lastName, email);
        this.isRegular = isRegular;
        this.salary = salary;
    }
}
----
<1> When you define a constructor in a JPA class, it is important to add a default constructor as well.
JPA is using reflection in order to set the values of the properties from the database.
Missing a default constructor will prevent JPA from creating an instance for your class.

==== The `EntityManager`

In order to be able to access the database, we will need to use a special interface, called `EntityManager`.
The entity manager has all the methods needed to read, persist, update and delete entities.

Let's add the `EntityManager` to our `AuthorResource`.

[source,java]
----
public class AuthorResource {

    EntityManager entityManager;

    public AuthorResource(EntityManager entityManager) { <.>
        this.entityManager = entityManager;
    }

    public Response createAuthor(AuthorDTO authorDTO) {}

}
----
<.> Thanks to the Quarkus ARC extension and CDI, we are able to provide instance of the entity manager, by just adding it to the class' constructor.
This approach is not that common and we are going to look at a more Jakarta EE way to inject dependencies in our CDI chapter.

Now let's define our `createAuthor` method and bind the DTOs to the entities.

[source,java]
----
@Path("/user")
public class AuthorResource {

    EntityManager entityManager;

    public AuthorResource(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createAuthor(AuthorDTO authorDTO) {
        Author author = new Author(authorDTO.getUserName(), authorDTO.getPassword(), authorDTO.getFirstName(),
                authorDTO.getLastName(), authorDTO.getEmail(), authorDTO.isRegular(), authorDTO.getSalary());
        entityManager.persist(author);

        return Response.created(URI.create(String.format("/user/author/%d",author.id))).build(); <.>
    }
}
----
<.> When the persist method is called and the `id` field is set to `null` or `0`, the persist method will assign it a new value.
This is the reason why we can use the id of the newly created object, without setting it ourselves.

All looks great, now let's deploy our application and create our first author.

[source,curl]
----
curl -i --location --request POST 'localhost:8080/user/author' \
--header 'Content-Type: application/json' \
--data-raw '{
    "userName": "cj_123",
    "password": "cj_pass",
    "firstName": "Cave",
    "lastName": "Johnson",
    "email": "cj@apperture-science.io",
    "isRegular": true,
    "salary": 10000
}'
----

`HTTP/1.1 500 Internal Server Error` Why?
If you look at the console, you may find the following error.

----
Transaction is not active, consider adding @Transactional to your method to automatically activate one.
----

==== The `@Transactional` annotation

Using the `EntityManager` on its own wouldn't help if there is no database session and transaction created.
As you know the database is a component detached from our project and requires connection to a server and data transmission.
In a real life scenario, the database can be physically separated from the web application, running on a different computer.
And since the database is our main origin of truth, we need to be sure what we wite to it is valid and consistent.
That's why transactions come in action.
The lifecycle of a database transaction is as follows:

. Create a database session (connect to the database)
. Start a transaction
. Execute select, update, delete operations
. Commit/Roll-back the transaction
. End the database session

Using JPA on its own will require you to create those sessions and transactions manually, by invoking methods from the `EntityManager` interface.
But having manual control over the transactions is a bit advanced for simple things, that could be managed automatically.
Jakarta EE and Quarkus have us fortunately covered.
Quarkus implements the JTA specification, which allows the transaction to be managed automatically by the application.
The only thing we need to do is to annotate our method with `@Transactional`.

.The Java™ Transaction API (JTA)
*****************************************
JTA is a general API that allows transactions in Java to be managed in a neutral way.
The session and transaction is managed by the application server, instead of the developer, which means the time a transaction opens and closes is managed by the server as well.

The alternative to JTA is called _local transaction_.
The local transaction allows the developer to decide when a session and transaction should be created and when it should be committed/rolled back.

Read more about JTA in https://www.progress.com/tutorials/jdbc/understanding-jta[this article].
*****************************************

Knowing all that, let's make our method transactional...

[source,java]
----
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Transactional
    public Response createAuthor(AuthorDTO authorDTO) {
        //code...
    }
----

That's all.
Now if you try and execute your request again, the author should be persisted.

----
HTTP/1.1 201 Created
Location: http://localhost:8080/user/author/1
content-length: 0
----

[TIP]
====
- `@Transactional` can be used on method and on a class level.
Using `@Transactional` on a class level is recommended only if all the methods in your class should be transactional.
- Queries that read from the database do not need to be transactional, hence they do not require the `@Transactional` annotation.
You need to use `@Transactional` only on methods, that induce changes on the database or when you need a high level of consistency when reading data to make sure nobody is changing it while you read it. 
====

To make sure that our author exists, let's create a query to get it from the database.

But first, let's define some constructors:

[source,java]
----

public abstract class UserDTO {

    //definitions
    
    public UserDTO() { <1>
    }

    public UserDTO(User user) {
        userName = user.userName;
        password = user.password;
        firstName = user.firstName;
        lastName = user.lastName;
        email = user.email;
    }

    //getters and setters
}

public class AuthorDTO extends UserDTO {

    //definitions

    public AuthorDTO() { <1>
    }

    public AuthorDTO(Author author) {
        super(author);
        isRegular = author.isRegular;
        salary = author.salary;
    }

    //getters and setters
}
----
<1> Just like JPA, JSON-B uses reflection to convert JSON into POJO and backwards.
For that reason access to a default constructor is needed.

And here is the definition of our `getAuthor` method.

[source,java]
----
@Path("/user/author")
public class AuthorResource {

    EntityManager entityManager;

    public AuthorResource(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public Response createAuthor(AuthorDTO authorDTO) { ... }

    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getAuthor(@PathParam("id") Long authorId) {
        if (authorId < 1) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            Author author = entityManager.find(Author.class, authorId);
            if (author == null) {
                return Response.status(Response.Status.NOT_FOUND).build();
            } else {
                return Response.ok(new AuthorDTO(author)).build();
            }
        }
    }
}
----

And if we try to call this endpoint, we should be able to get our author.

----
curl -i --location --request GET 'http://localhost:8080/user/author/1'
HTTP/1.1 200 OK
Content-Type: application/json
content-length: 147

{"email":"cj@apperture-science.io","firstName":"Cave","lastName":"Johnson","password":"cj_pass","userName":"cj_123","regular":false,"salary":10000}
----

==== Upgrading the `ArticleResource`

Now that we are ready with the author, let's integrate it with the article.
First off, it's time for some changes:

. Add constructors to the `Article` entity
+
[source,java]
----
@Entity
public class Article extends AbstractEntity {
    
    // definitions

    public Article() {
    }

    public Article(String title, String content, LocalDate publishDate, Author author) { <.>
        this.title = title;
        this.content = content;
        this.publishDate = publishDate;
        this.author = author;
    }
}
----
<.> For now we will decide not to assign comments to the article.

. Next step is changing `author` to `authorId` inside the `ArticleDTO`, and adding constructors as well.
+
[source,java]
----
public class ArticleDTO {

    // definitions

    public ArticleDTO() {
    }

    public ArticleDTO(Article article) {
        this.id = article.id;
        this.title = article.title;
        this.content = article.content;
        this.publishDate = article.publishDate.toString();
        this.authorId = article.author.id;
    }

    // getters and setters
}
----

. Now that we're done with that, it's time to refactor `ArticleResource` class method by method.

==== Creating an article

Let's see how we can apply our knowledge from creating an author into creating an article.

First we need to introduce the `EntityManager` to the class:

[source,java]
----
...
    private EntityManager entityManager;

    public ArticleResource(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
...
----

Then we refactor the `createArticle` method:

[source,java]
----
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Transactional <.>
    public Response createArticle(ArticleDTO articleDTO) {
        Author author = entityManager.find(Author.class, articleDTO.getAuthorId());
        if (author == null) {   <.>
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            Article article = new Article(articleDTO.getTitle(), articleDTO.getContent(),
                    LocalDate.parse(articleDTO.getPublishDate()),author);
            entityManager.persist(article);

            return Response.created(URI.create(String.format("article/%s", article.id))).build();
        }
    }
----
<.> Don't forget that this action is `@Transactional`
<.> It is important to make sure that the article has an author to avoid any relational errors.

This should be enough to create articles.
Now the call for creating an article would change to:

[source,java]
----
curl -i --location --request POST 'http://localhost:8080/article/' \
--header 'Content-Type: application/json' \
--data-raw '{
    "title": "Article for the soul.",
    "content": "The quick brown fox runs over the lazy dog.",
    "publishDate": "2022-01-12",
    "authorId": 1
}'
----

Other than that, everything should remain the same.

==== Getting the article

If you try to call the `getArticle` endpoint, though you will be met with `404` response.
This is because we're now saving the articles to the database, not within the map.
So let's get articles from our database instead.

[source,java]
----
    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response getArticle(@PathParam("id") Long articleId) {
        if (articleId < 1>) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Article article = entityManager.find(Article.class, articleId);

        if(article == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            return Response.ok(new ArticleDTO(article)).build();
        }
    }
----

Mentioning again, getting an article, does not induce any changes to the database so `@Transactional` here is not needed.
Query this endpoint again, and you should be seeing the results.

==== Getting a list of articles (Pagination)

Since we are in the getting part, let's see what kind of options we have when it comes to getting all articles by pages.

A paginated query to the entity manager would look like that:

[source,java]
----
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public Response getArticles(@QueryParam("page") @DefaultValue("1") int page,
                                @QueryParam("size") @DefaultValue("10") int size) {
        if (page < 1 || size < 0) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        } else {
            List<Article> articles = entityManager.createQuery("select a from Article a", Article.class) <.>
                    .setFirstResult((page - 1) * size) <.>
                    .setMaxResults(size) <.>
                    .getResultList();

            List<ArticleDTO> articleDTOs = articles.stream()
                    .map(ArticleDTO::new)
                    .collect(Collectors.toList());

            return Response.ok(articleDTOs).build();
        }
    }
----
<.> The create query method will take an https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryJPQL.html[JPQL language] query and convert it to the specific language the database works with.
Since the entity manager does not have a method to request a list of all entities out of the box, we need to specifically query that.

Now if we try and call the endpoint, we are going to get the same result, like we did when we used tha map.

But let's not just limit ourselves with just getting all the articles.
What if our users want to see the articles of a specific author?

It's time to touch our `getArticles` even a bit more and make it smarter.
Why don't you try and modify it yourself?

Here are some tips:
. Add a new query parameter to the endpoint, called `authorId`
. Check if that id is valid - if the id is null, get all articles, if the id is not null, create a query with a where clause...

.Using the `where` clause with entity manager.
====
Using the `entityManager.createQuery()` method we can define any query that we want, but what is the proper way to define a query like that:

[source,sql]
----
select a from Articles where a.author.id = 1
----

First thing that would come to the untrained mind is to use the `String.format()` method, or any type of concatenation where the variable will be.
But there is a more lean way to do that.

With the `setParameter()` method, you can neatly set parameters to your query.
In order to use the `setParameter` method, we need to define our query like this:

[source,sql]
----
select a from Article a where a.author.id = :authorId
----

or if we do not want to give the parameter a name

[source,sql]
----
select a from Article a where a.author.id = ?1
----

Then in Java we would use the set parameter as follows:

[source,java]
----
List<Article> articles = entityManager.createQuery("select a from Article a where a.author.id = :authorId")
    .setParameter("authorId", authorId)
    .getResultList();

// or in the case of param number

List<Article> articles = entityManager.createQuery("select a from Article a where a.author.id = :authorId")
    .setParameter(1, authorId)
    .getResultList();
----

Using this knowledge, now you can properly define your query for getting articles by author.

====

Now that you are able to query articles by authors, you have a more real-life endpoint that is suitable to work with.

.Adding `insert.sql` script
*****************************************
All's good, but don't you get tired from creating authors and articles every time you need to test something?
Let's change that a bit.

Add a file, called `import.sql` into `main/resources` folder.
And add the following script:

[source,sql]
----
insert into Users (version, email, firstName, lastName, password, userName, isRegular, salary, DTYPE, id)
values (0, 'cj@apperture-science.io', 'Cave', 'Johnson', 'cj_pass', 'cj_123', true, 10000, 'Author', 1),
       (0, 'jane@apperture-science.io', 'Jane', 'Doe', 'jd_pass', 'jd_123', true, 10000, 'Author', 2);


insert into ARTICLE (ID, VERSION, CONTENT, PUBLISHDATE, TITLE, AUTHOR_ID)
values (3, 0, 'The quick brown fox runs over the lazy dog.', '2022-01-12', 'Article for the soul.', 1),
       (4, 0, 'This is an article by the same author, who created Ipsum Lorem', '2022-02-12', 'The aitor that created',
        1),
       (5, 0, 'This is how I got my hands into Java long time ago. Long article here...', '2020-01-10',
        'The way I became Java developer', 2),
       (6, 0, 'This is my extreme enjoyment of Quarkus, written in an article', '2022-09-13',
        'I love Quarkus and Quarkus loves me back', 2);


alter sequence USERS_SEQ restart with 10;
alter sequence ARTICLE_SEQ restart with 10;
alter sequence COMMENT_SEQ restart with 10;
alter sequence ADVERTISER_SEQ restart with 10;
----

Now every time the application has started, reloaded it will insert those entries, so the database will always be filled with some data.
*****************************************

==== Updating an article

Continuing out progress, let's see how an article is updated.

[source,java]
----
    @PUT
    @Path("/{id}")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Transactional
    public Response editArticle(@PathParam("id") Long articleId, ArticleDTO articleDTO) {
        if (articleId < 1) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }

        Article article = entityManager.find(Article.class, articleId);

        if (article == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        } else {
            article.content = articleDTO.getContent();
            article.publishDate = LocalDate.parse(articleDTO.getPublishDate());
            article.title = articleDTO.getTitle();

            entityManager.merge(article); <.>
            return Response.ok(new ArticleDTO(article)).build();
        }
    }

----
<.> Usage of `entityManager.merge()` here is optional.
As long as the invocation of the `find` method has been made within a `@Transactional` method, you needn't call `entityManager.merge()`.
When the transaction is finished, all the modifications on the article class will be automatically persisted.

.`persist()` vs `merge()`
*****************************************
Getting an article object doesn’t always mean that you get an article entity. This is because the objects have different states when JPA is regarded.
The below figure shows how this works:

image::entity-state-chart.png[title="Entity state diagram",align="center"]

When calling the `persist()` on an entity class, the entity manager, will always try to create a new entity.
The entity then is tracked by the entity manager (merged) and all the changes done to it, within the `@Transactional` context will be executed upon transaction flushing.

If the entity is detached, when the instance of an entity is passed outside a transactional context for example, you will need to call `entityManager.merge()` in order to connect it to an entity inside the database.
The method will look for the entity by its id and apply all the changes to that entity.
This method should be used only on already existing entities.

Due to the way our endpoints are constructed, having to merge an entity is a rare occasion, but not unfeasible.
If you happen to stumble upon a situation, where you need to call the `merge` method, and you didn't you'll probably get an exception, stating that the entity has not been merged to be persisted.

Then you'll need to refactor your implementation and invoke `merge()` where needed.

*****************************************

==== Deleting an article

Moving forward with our last CRUD operation - deleting an article.
One way to define it is like that:

[source,java]
----
    @DELETE
    @Path("/{id}")
    @Transactional
    public void deleteArticle(@PathParam("id") Long articleId) {
        if (articleId != null && articleId >= 1) {
            Article article = entityManager.find(Article.class, articleId);
            entityManager.remove(article);
        }
    }
----

Although there is a problem here.
Instead of making one query, we are making two.
First we select an article, that might be existing in the database, then we invoke delete on it.

[TIP]
====
Why don't you try to create a query for deleting the article with a single query?
This is your task.

And here are some hints:

. Use what you already know about creating custom queries
. To execute your query, invoke the method, called `executeUpdate()`
====

==== Optimizing our queries

Using the `entityManager.createQuery()` method, might add some delay to our queries.
In our scenario we don't see that, because we are working with small amount of data, but in a broad scenario, it would take some time to interpret the query and translate it to the native SQL language for the regarded database.
Imagine putting this in a loop, and every time the method is invoked, it has to interpret your query again and again.
It's impractical.

Using this method is only recommended when the query is quite dynamic.
In our case all of our queries are mostly static.
The only difference is a variable here and there.
Thankfully JPA offers another more optimized approach for static queries.
Presenting "*Named queries*".
Named queries are queries, which are specified on class level and are interpreted at the startup of the application.
So every time you create a query, you are going to use its native language under the hood.

Let's now go to our `Article` class and create a couple of named queries, that we use for our endpoints.

[source,java]
----
@NamedQuery(name = Article.GET_ALL_ARTICLES, query = "select a from Article a") <.>
@NamedQuery(name = Article.GET_ALL_ARTICLES_FROM_AUTHOR, query = "select a from Article a where a.author.id = :authorId")
@NamedQuery(name = Article.DELETE_ARTICLE, query = "delete from Article a where a.id = :articleId")
public class Article extends AbstractEntity {

    //It is recommended to use constants, so if the name changes, it should be only in one place.  
    public static final String GET_ALL_ARTICLES = "Article.getAllArticles"; <.>
    public static final String GET_ALL_ARTICLES_FROM_AUTHOR = "Article.getAllArticlesFromAuthor";
    public static final String DELETE_ARTICLE = "Article.deleteArticle";

    //rest of the code
}
----

<.> With the `@NamedQuery` annotation, we are telling JPA/Hibernate, to interpret a query for that JPQL query at server startup.
<.> Names of the queries should be unique, as it does not matter where the annotation is placed.
You can literally place it on a different class, and it will work without any problems.
The only way for JPA to find your query is by its unique name.

Now let's replace all occurrences of `entityManager.createQuery()`, with `entityManager.createNamedQuery()` in our `ArticleResource`.

TIP: Try and do it yourself.
Use the constants for passing the name of the query.

==== Conclusion

As with JAX-RS that's not all.
There is more to learn for the JPA spec, and we are going to give you more examples along this course. 
But never stop being curious!
Go onto the internet, play with the code we have created and see how it all works.

Our next step is to see how Quarkus Panache comes in action and simplify those queries even further.